/*
===============================================================================
Driver Name		:		blkio_regulator
Author			:		VAMSEE
License			:		GPL
Description		:		LINUX DEVICE DRIVER PROJECT
===============================================================================
*/

#include"blkio_regulator.h"
#include <linux/device.h>
#include <linux/blkdev.h>
#include <linux/genhd.h>
#include <linux/ktime.h>
#include <linux/timer.h>
#include <linux/jiffies.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("VAMSEE");

extern void printk_all_disks(struct list_head *blk_reg_head);

/*struct registered_devices {
	char *type;
	struct device dev;
	struct gendisk disk;
	struct list_head list;
};*/

struct regulator_data{
	struct request_queue *q;
	//struct hrtimer fb_timer;
	struct timer_list fb_timer;
	struct list_head blk_reg_head;
};

struct regulator_data *rgl_data = NULL;

static int alloc_regulator(void){
	rgl_data = (struct regulator_data *)kmalloc(sizeof(
			struct regulator_data),GFP_KERNEL);
	if(!rgl_data)
		return 1;

	return 0;
}

static void unalloc_regulator(void){
	kfree(rgl_data);
}

static void update_cfq_iops(struct request_queue *q, unsigned long latency){
	struct cfq_data *cfqd;

	cfqd = q->elevator->elevator_data;
	//cfqd->cfq_slice_async_rq = latency/25;
}

/*
 * calc_latency - calculate the latency of a block device using the requests send to
 * a specific block device (request queue)
 * @q: 	request queue allocated to a block device
 *
 * return value:	calculated/estimated latency of a block device.
 */
static unsigned long int calc_latency(struct request_queue *q){
	struct request *rq;
	struct list_head *queue_head;
	unsigned long int data = 0;

	queue_head = &q->queue_head;

	list_for_each_entry(rq, queue_head, queuelist) {
		data += rq->__data_len;
		for(rq = rq->next_rq; rq != NULL; rq = rq->next_rq)
			data += rq->__data_len;
	}

	/* apply Dan's method for calculating latency based on total data
	 * to be processed
	 */
	return data;
}

/*
 * scan_and_get_blk_device - scan all the block devices registered with
 * the block io and search for a specific device of interest as of now.
 * @list : registered block devices list
 *
 * return value : request queue of block device in interest
 */
static struct request_queue *scan_and_get_blk_device(struct list_head *dev_list){
	struct registered_devices *blk_reg_dev;

	list_for_each_entry(blk_reg_dev,dev_list,list){
		if(likely(strcmp(blk_reg_dev->disk.disk_name, "sda") == 0)){
			printk(KERN_INFO "disk name: %s\n", blk_reg_dev->disk.disk_name);
			return blk_reg_dev->disk.queue;
		}
	}
	return NULL;
}
/*static enum hrtimer_restart feedback_timer(struct hrtimer *timer)
{
	unsigned long int latency;

	printk(KERN_INFO "hrtimer\n");

	PINFO("Max number of requests for this device is : %lu\n",rgl_data->q->nr_requests);
	//rgl_data->q = scan_and_get_blk_device(&rgl_data->blk_reg_head);
	//latency = calc_latency(rgl_data->q);
	// if latency is too large or too slow update cfq_iops
	//update_cfq_iops(rgl_data->q, latency);

	return HRTIMER_RESTART;
}*/

void feedback_timer(unsigned long int data){
	PINFO("Max number of requests for this device is : %lu\n",rgl_data->q->nr_requests);
	latency = calc_latency(rgl_data->q);
	update_cfq_iops(rgl_data->q, latency);
	mod_timer(&rgl_data->fb_timer,jiffies+5*HZ);
}
	
static int __init blkio_regulator_init(void)
{

	PINFO("INIT\n");
	if(alloc_regulator()){
		printk(KERN_INFO "Error allocting regulator data\n");
		return 0;
	}

	INIT_LIST_HEAD(&rgl_data->blk_reg_head);
	printk_all_disks(&rgl_data->blk_reg_head);

	rgl_data->q = scan_and_get_blk_device(&rgl_data->blk_reg_head);
	if(rgl_data->q == NULL)
		return 0;
	PINFO("Max number od requests for this device is : %lu\n",rgl_data->q->nr_requests);

	rgl_data->fb_timer.expires = jiffies + 5*HZ;
	rgl_data->fb_timer.function = feedback_timer;
	rgl_data->fb_timer.data = &rgl_data->blk_reg_head;	
	init_timer(&rgl_data->fb_timer);
	add_timer(&rgl_data->fb_timer);
	/*hrtimer_init(&rgl_data->fb_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	rgl_data->fb_timer.function = feedback_timer;

	hrtimer_start(&rgl_data->fb_timer, ms_to_ktime(10000), HRTIMER_MODE_REL);*/
	return 0;
}

static void __exit blkio_regulator_exit(void)
{	
	PINFO("EXIT\n");
	//while(hrtimer_active(&rgl_data->fb_timer));

	del_timer_sync(&rgl_data->fb_timer);
	//hrtimer_cancel(&rgl_data->fb_timer);
	unalloc_regulator();
}

module_init(blkio_regulator_init);
module_exit(blkio_regulator_exit);
